# 서버 권위적 아키텍처 의사결정 회고

## 개요

ChaosRPS.io 프로젝트에서 **서버 권위적 아키텍처(Server-Authoritative Architecture)**를 선택한 이유와 구현 전략을 기록합니다.

## 의사결정 배경

### 문제 상황

실시간 멀티플레이어 게임에서는 다음과 같은 핵심 문제가 존재합니다:

1. **동기화 문제**: 여러 클라이언트 간 게임 상태가 일치해야 합니다
2. **치팅 방지**: 클라이언트 측 조작을 통한 부정행위를 막아야 합니다
3. **지연 시간(Latency)**: 네트워크 지연으로 인한 사용자 경험 저하를 최소화해야 합니다

### 고려한 대안

| 아키텍처 | 장점 | 단점 |
|---------|------|------|
| **P2P (Peer-to-Peer)** | 서버 비용 절감, 낮은 지연 | 치팅에 취약, 동기화 복잡 |
| **클라이언트 권위적** | 빠른 반응성 | 치팅에 매우 취약 |
| **서버 권위적** | 치팅 방지, 일관된 상태 | 서버 부하, 지연 시간 |

## 선택: 서버 권위적 아키텍처

### 선택 이유

1. **공정성 보장**: 가위바위보 상성 판정은 게임의 핵심입니다. 클라이언트가 이를 조작할 수 없어야 합니다.

2. **랜덤 변신 무결성**: 1.5초마다 발생하는 랜덤 변신은 서버에서만 결정되어야 합니다. 클라이언트가 자신에게 유리한 상태로 변신하는 것을 방지합니다.

3. **점수 및 크기 검증**: 점수와 크기는 충돌 판정 결과에 따라 서버에서만 계산됩니다.

### 구현 전략

```
┌─────────────────────────────────────────────────────────────┐
│                        서버 (권위자)                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │ Transform   │  │ Collision   │  │ Movement    │         │
│  │ System      │  │ System      │  │ System      │         │
│  │ (변신 결정)  │  │ (충돌 판정)  │  │ (위치 검증)  │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
│                         │                                   │
│                    게임 상태 브로드캐스트                      │
└─────────────────────────────────────────────────────────────┘
                          │
          ┌───────────────┼───────────────┐
          ▼               ▼               ▼
     ┌─────────┐    ┌─────────┐    ┌─────────┐
     │클라이언트│    │클라이언트│    │클라이언트│
     │   A     │    │   B     │    │   C     │
     └─────────┘    └─────────┘    └─────────┘
```

## 클라이언트 사이드 예측 (Client-Side Prediction)

서버 권위적 아키텍처의 단점인 지연 시간 문제를 해결하기 위해 **클라이언트 사이드 예측**을 적용합니다.

### 개념 설명

클라이언트 사이드 예측(Client-Side Prediction)이란, 클라이언트가 서버의 응답을 기다리지 않고 먼저 자신의 입력 결과를 예측하여 화면에 반영하는 기법입니다. 이후 서버로부터 실제 결과를 받으면 예측과 비교하여 보정합니다.

### 적용 범위

| 항목 | 예측 적용 | 이유 |
|------|----------|------|
| 플레이어 이동 | ✅ | 즉각적인 반응성 필요 |
| 변신 예고 | ✅ | 0.5초 전 시각적 피드백 |
| 충돌 판정 | ❌ | 서버만 결정 (치팅 방지) |
| 점수/크기 변경 | ❌ | 서버만 결정 |

### 구현 흐름

```
1. 클라이언트: 입력 발생 → 즉시 로컬 상태 업데이트 (예측)
2. 클라이언트: 서버로 입력 전송
3. 서버: 입력 검증 및 처리
4. 서버: 권위적 상태 브로드캐스트
5. 클라이언트: 서버 상태와 로컬 예측 비교
6. 클라이언트: 차이가 있으면 보정 (Reconciliation)
```

## 치팅 방지 전략

### 1. 입력 검증

```typescript
// MovementSystem.ts에서 구현
export function validateMovement(
  currentPos: Position,
  targetPos: Position,
  deltaTime: number,
  playerSize: number
): Position {
  const maxSpeed = calculateMaxSpeed(playerSize);
  const maxDistance = maxSpeed * deltaTime;
  
  // 이동 거리가 최대 허용치를 초과하면 제한
  const distance = calculateDistance(currentPos, targetPos);
  if (distance > maxDistance) {
    // 방향은 유지하되 거리만 제한
    return clampMovement(currentPos, targetPos, maxDistance);
  }
  
  return targetPos;
}
```

### 2. 상태 변조 방지

- 클라이언트가 보내는 데이터: **입력(이동 방향)만**
- 서버가 계산하는 데이터: 위치, 상태, 점수, 크기, 충돌 결과

### 3. 속도 해킹 방지

- 크기에 따른 최대 속도 제한을 서버에서 강제
- 비정상적인 이동 패턴 감지 시 위치 보정

## 시스템 구조

현재 구현된 서버 시스템들:

### TransformSystem (변신 시스템)

- 1.5초 주기로 모든 플레이어의 RPS 상태를 랜덤 변경
- 0.5초 전 예고 이벤트 발송
- 균등 랜덤 분포 보장 (Property 1 테스트로 검증)

### CollisionSystem (충돌 시스템)

- 두 플레이어 간 충돌 감지
- 가위바위보 상성에 따른 결과 판정 (승리/무승부/패배)
- 100% 정확한 판정 보장 (Property 2 테스트로 검증)

### MovementSystem (이동 시스템)

- 클라이언트 입력 기반 위치 업데이트
- 크기에 따른 속도 제한 적용
- 경계 검사 및 위치 보정

### Player (플레이어 엔티티)

- 점수에 따른 크기 계산 (단조 증가 함수)
- 상태 관리 및 직렬화

## 결론

서버 권위적 아키텍처는 ChaosRPS.io의 공정성과 무결성을 보장하는 핵심 설계 결정입니다. 클라이언트 사이드 예측을 통해 사용자 경험을 유지하면서도, 모든 중요한 게임 로직은 서버에서 처리하여 치팅을 원천 차단합니다.

## 참고 자료

- [Gabriel Gambetta - Fast-Paced Multiplayer](https://www.gabrielgambetta.com/client-server-game-architecture.html)
- [Valve Developer Community - Source Multiplayer Networking](https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking)
